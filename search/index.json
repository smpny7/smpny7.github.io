[{"content":"察してください、ネタ回です 今回どういった話かというと、友人十数名が入ったDiscordサーバーがあるのですが、 そのサーバー用の Bot を作るという箸休め回です。 この Bot は、みんなが登録した語録を紐づけたトリガーに応じてつぶやいてくれるという Bot なのですが、 正直にいうとこの「草Bot」を作ったきっかけが一切記憶にないんです(笑)\nでも盛り上がって、つくることになった 草Botくん、「草」という文字が入っていると、「草」と返してくれることからこの名前がついたんです。\n 草Botくん \n実はこの草Bot、今はおもちゃにされています。 （もはやBotの表示名も変えられてますw）\n敗因: 誰でもプルリクOK＆自動デプロイ仕様にしてしまった 最初は「草」と返してくれる Bot だったのですが、サーバーメンバーがこの Bot にどんどん単語を登録していきました。 ただ、そのセンスがかなり良すぎるので、本来の目的が語録に変わって私も大満足です(笑)\nせっかくなので、自分のお気に入り語録を紹介しましょう。\n これ何だかわかりますか？\n お気に入り語録 その1 \n↑ これをみてピンときた人はさすがですね ！\n  実はこれ \nこれですね！いつものやつです。\n実は以前、みんなで Raspberry Pi OS をセットアップしてた時ですが、 日本語化がうまくいかず、文字化けで何も見えない現象が発生してしまいました。\n唯一文字化けしていても意味がわかった文面が上の文字列で、\n 伏字にしているのに、隠せれてないwwww\n ということで追加されました(笑)\n もう一つのお気に入りはこれです。\n 「腹痛」に反応します \n「腹痛」という単語を聞くと、よくわからない係数を測ってくれ、それに応じてアナウンスが流れます。\n 元ネタはこちら ニコニコ大百科（ドミネーター）\n しかもこれは、例のよくわからない係数（乱数）に応じてメッセージが変わります。\n今回の技術的なコト Node.js で作りましたが、Bot はすぐできるので記事にするほどでもないかと思います。\n詳しくは以下のドキュメントをどうぞ！\n 公式ドキュメント https://discord.js.org\n 今回、この Bot は Herokuにデプロイしているので、こちらの知見を共有したいと思います。 Herokuでは、GitHubリポジトリとHerokuAppを連携させることができます。連携しておくと、 GitHubのmainブランチにプッシュされた時に WebHook が飛ばされ Heroku に自動でデプロイされるのでとても便利です。\nただ今回、気をつける点が2つありました。\n Procfile を作成すること プロセスタイプを worker に設定すること  この2つを共有して、本記事の締めにしたいと思います。\nProcfile を作成すること Procfile とは、デプロイ時にどのようなコマンドで run（開始）するかを記述したものです。\nProcfile | Heroku Dev Center には以下のような記述があります。\n Herokuによりサポートされているほとんどの言語で書かれたアプリをデプロイするのに、Procfileは必要はありません。\n  プラットフォームが使われている言語を自動的に検知し、アプリケーションサーバーを起動するために、デフォルトのwebプロセスタイプを作成してくれます。\n しかし自動的に検知してくれなかったのか、私の環境では実行されなかったので Procfile を作成しました。\n書き方は以下の通りです。\n(processType) : (command) 今回の場合、以下の記述が必要です。\nworker: node index.js Procfile はアプリのルートディレクトリに設置する必要があります。\ndyno を worker に設定すること もう1つ、今回 Heroku 独特のプロセス処理の種類である dyno をデフォルトから変更する必要がありました。\ndyno には web , worker , one-off の3種類があります。\n   種類 機能     Web ルーターから HTTP トラフィックを受信し、通常は Web サーバーを実行します。   Worker バックグラウンドジョブ、キューイングシステム、時間指定のあるジョブなどを実行します。   One-off 管理タスクの処理（REPL シェルを実行してデータベースの移行や一時的なバックグラウンド作業を行う場合など）に使用します。    今回、Discord Bot では常にチャンネルのテキストを取得する必要があるため、worker に設定する必要があります。\nHerokuCLI を導入している場合は、以下のコマンドで worker に切り替えることができます。\nheroku ps:scale worker=1 さいごに なんだかんだ、やっぱりBotがいてくれると楽しいですよね。\n次はもっと有用な Bot を作りたいと思います (笑)\n","date":"2021-04-25T00:00:00+09:00","image":"https://coalabo.net/p/wbot/cover_hub8c1acb45d2236871445ffc5c0753e18_55702_120x120_fill_q75_box_smart1.jpg","permalink":"https://coalabo.net/p/wbot/","title":"草bot (wbot) の開発談"},{"content":"やっぱアプリ化、したいよね！！ Webベースのツールを作ると、そのアプリ版を作りたくなる、ここまでがテンプレですよね。\n今回は、ストアにリリースが手軽な Android アプリを制作したいと思います。\nAndroid Studio 使いやすい\u0026hellip; この時、プログラミングというものに触れてまだ半年もたっていませんでした。 なので初心者でも使いやすい Visual Studio Code を当時愛用していました。（今でも時々使っています）\nしかし今回アプリ開発というのもあり、デバッグのしやすいエディタを使うことにしました。 まぁもちろん Android Studio 一択になるわけですが。 JetBrains 社が開発したソフトウェアを初めて触ったのですが、 これがまた使いやすいソフトウェアで感動したのを覚えています。 （私が JetBrains 信徒になる話はまたいつか）\n Android Studio のデザイン画面 \nさぁ開発だ！ の前に、デザインを作っていきます。\nスマホによってサイズが異なるので、対応できるデザインを意識して作成しました。\n Adobe XD \nコーディング すべしぬべし 今回の技術的な部分です。サーバーの様子を取得するのとリクエストを送る機能をつけます！（大したことはしてませんが）\n スプラッシュ画面（情クラ！アプリ）  ホーム（情クラ！アプリ） \nまず、オンラインプレイヤーの取得部分です。 ホーム画面の上半分には、オンラインのメンバーが一覧でわかるようにしています。\n今回、Minecraftの画像を取得するAPIを自作しました。 そこからAndroidに画像を取得するようにしています。 APIからの画像取得には、Picasso というライブラリを使用しました。\n Picasso（公式サイト） https://square.github.io/picasso/\n 具体的には、以下のような書き方でさくっとインターネットから画像取得ができちゃうものです！\nPicasso.get() .load(\u0026#34;https://jokura.net/api/getSkin?id=minecraft_id\u0026#34;) // 今回作成したAPI  .into(face1); face1というのは ImageView の id で、APIから取得した画像を流し込んでくれます！\nまた、プレイヤーがオンラインかどうかは、用意したAPIから返ってきた情報を元に表示を切り替えます。 APIからのGET・POSTメソッドには、便利な OkHttp3 などの便利なライブラリがありますが、 この時は初心者だったこともあり、Java通信（HttpUrlConnection）で実装しました(笑)\nvar connection: HttpURLConnection? = null var reader: BufferedReader? = null val buffer: StringBuffer try { val url = URL( /* 通信するAPI */ ) connection = url.openConnection() as HttpURLConnection connection.connect() // ここで指定したAPIを叩いています。  // 取得したデータを処理していきます。とりあえず取得した文字をbufferに。  val stream = connection.inputStream reader = BufferedReader(InputStreamReader(stream)) buffer = StringBuffer() var line: String? while (true) { line = reader.readLine() if (line == null) break buffer.append(line) } // ここからJSONに変換していきます。  val jsonText = buffer.toString() val parentJsonObj = JSONObject(jsonText) // オンラインメンバーの情報は、JSON内の top というキーの中に格納してあります。  val parentJsonArray = parentJsonObj.getJSONArray(\u0026#34;top\u0026#34;) val detailJsonObj = parentJsonArray.getJSONObject(0) // player1さんのオンライン状況が取得できました！  val player1: Int = detailJsonObj.getInt(\u0026#34;player1\u0026#34;) return player1 } catch (e: MalformedURLException) { e.printStackTrace() } catch (e: IOException) { e.printStackTrace() } catch (e: JSONException) { e.printStackTrace() } // 接続を切断してあげましょう。おつかれ！ finally { connection?.disconnect() try { reader?.close() } catch (e: IOException) { e.printStackTrace() } } // 失敗した時はnullやエラーコードなどを返しましょう。 return null } 一部抜粋していますが、こんな感じでリクエストをかいています。\nちょっと脱線しちゃいましたね 他にどんな機能を実装したのかみてみましょう！たぶんこちらの方が興味ありますよね (笑)\n ホーム（情クラ！アプリ）  サーバー稼働状況（情クラ！アプリ） \nトップ画面には、「バックアップ」と「再起動」の2つのボタンが用意してあります。 この2つのボタンについては後述します。\nまた、「稼働状況」を押すとサーバーの現在の状況をみることができます。 今思うと、ここのデザインは Web 版と同じなので、 WebView で表示させるとよかったですね (笑)\nとりあえず、今回は xml ファイルで view を丁寧に記述しました。\n今回のメインディッシュ 本アプリのメイン機能は、なんといってもこの2つです！\nトップに設置されている「バックアップ」「再起動」の機能について説明します。\n バックアップ 実行不可（情クラ！アプリ）  バックアップ 実行可能（情クラ！アプリ） \nこの Activity の開始と同時に、バックエンドと通信して 再起動 または バックアップ が実行できるか確認して、表示を切り分けます。\n実行できない例としては、\n サーバーが停止している 他のユーザが現在処理を行っている 処理実行後のクールタイムにある  のいずれかですね。右上の更新ボタンで最新情報を再取得できます。\n今回、神経を使ったのは処理部分でした なんといってもサーバー関連で怖いのが、リクエストが同時に送られることですよね。\n今回、サーバーを制御できるプラットフォームが複数あるため、他のアプリやWebサイトから同時にリクエストが送られた場合、最初のリクエストのみ通す必要があります。 また、再起動やバックアップなどが実行された後は、クールタイムを設ける必要もあります。\nそういった、さまざまなリクエストを処理できるように、情クラ！ではバックエンドのAPIを用意し、そこからサーバー処理を行っています。 リクエストが失敗した場合には、その理由をエラーコードで返しユーザに通知しています。 実行可能の状態でボタンを押した場合でも、バックエンドでキャンセルされた場合その旨のトーストが表示されます。\n２年の月日を経て\u0026hellip; 前回の記事でも述べた通り、情クラ！はサービス終了しました。\n今回、\u0026ldquo;プログラムの整合性\u0026rdquo; というものを勉強できた、サービス開発だったと思います。\n他にも Minecraft 関係で得た知見はかなり大きいものだったので、今後何か一般向けのサービスに繋げていきたいと思います。\n","date":"2021-04-23T09:19:41+09:00","image":"https://coalabo.net/p/jokura-app/cover_hu4de8297eba748400c5bc7c54477d6389_102123_120x120_fill_q75_box_smart1.jpg","permalink":"https://coalabo.net/p/jokura-app/","title":"アプリ版 Minecraft サーバー制御ツールの制作"},{"content":"Minecraft っていいよね Minecraft って、複数人でプレイすると沼ですよね。\n「 情クラ！」という、知り合い十数名程度の Minecraft サーバーで遊んでいるのですが、 今や大陸内には高速道路が広がり、複数の大陸間には大きな橋が建築されています。（やばすぎ）\n 瀬戸大橋（こんなのが 5, 6本架かっています） \nある日、Minecraft のサーバー管理者になった 最初はみんなで家に集まって、ローカルでサーバーを建ててプレイしていました。 しかしプレイヤーがどんどん増えてきたため、Google Cloud Platform（GCP）でサーバーを立てることにしました。\nこれが、「情クラ！」という Minecraft サーバーの誕生のきっかけです。\nいつどこでも Minecraft サーバーで遊べる環境が完成し、ワールドの発展度合いが加速度的に大きくなったのですが、 しかし1つ大きな問題がでてきました。\nこれは、Google Cloud Platform（GCP）がまだ365日無料トライアルだった頃の話なのですが、 当時GCPには、年間 30,000円分の無料クレジットが付属していました。 それをちょうど1年間で使い切るn1-standard-1 プラン（仮想 CPU 数: 1, メモリ: 3.75 GB）で運用していたのですが、 大人数が長時間プレイしていると動作がもっさりしてくるのです。\n GCPの料金（N1 標準マシンタイプ） \nサーバー管理者だった私は、連絡を受けるたび SSH 接続してサーバーを再起動していました。\nですがここは、ぜひ技術の力で課題解決をしよう！ということで、Minecraftサーバーを誰でも簡単に制御できる、Webアプリケーションを作成することになりました。\nまずは完成品をどうぞ  トップページ（情クラ！）  サーバー状況確認ページ（情クラ！） \n最初に実装したのは、「ホーム」のお知らせ（左）と「サーバー状況」の確認画面（右）です。 モバイルファーストのデザインですが、きちんとレスポンシブ対応させています。\n以下、それぞれの軽い機能紹介です。\n   ページ 機能     ホーム プレイヤーが自由に建築報告を投稿することができます   サーバー状況 サーバーの起動・停止状況やオンラインメンバーを確認できます    ここで、少し技術的な話をしましょう 一応そういうブログ（ ？）なので、今回 Minecraft サーバーと連携したノウハウについて記述しておきます。\nMinecraft サーバーでは、ある特定のパケットを受け取ると、現在のサーバーのステータスを返す機能が搭載されています。 こちらのページに詳しい仕様が載っています。 これらの仕様は、Minecraft 起動時のマルチプレイ選択画面などに利用されているそうです。\n続いて、詳しい仕様について順を追って説明していきます。\nまず、クライアント側が以下のような Handshake パケットを送信します。\n   Packet ID Field Name Field Type Notes     0x00 Protocol Version VarInt See protocol version numbers. The version that the client plans on using to connect to the server (which is not important for the ping). If the client is pinging to determine what version to use, by convention -1 should be set.   ^ Server Address String Hostname or IP, e.g. localhost or 127.0.0.1, that was used to connect. The Notchian server does not use this information. Note that SRV records are a complete redirect, e.g. if _minecraft._tcp.example.com points to mc.example.org, users connecting to example.com will provide mc.example.org as server address in addition to connecting to it.   ^ Server Port Unsigned Short Default is 25565. The Notchian server does not use this information.   ^ Next state VarInt Should be 1 for status, but could also be 2 for login.    ここで重要なのが、このレスポンスを待たずに続けてリクエストパケットを送信します。 その応答パケットとして、サーバーが以下のようなJSONを返します。\n{ \u0026#34;version\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;1.16.1\u0026#34;, \u0026#34;protocol\u0026#34;: 47 }, \u0026#34;players\u0026#34;: { \u0026#34;max\u0026#34;: 12, \u0026#34;online\u0026#34;: 5, \u0026#34;sample\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;minecraft_name\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;4566e69f-c907-48ee-8d71-d7ba5aa00d20\u0026#34; } ] }, \u0026#34;description\u0026#34;: { \u0026#34;text\u0026#34;: \u0026#34;Hello world\u0026#34; }, \u0026#34;favicon\u0026#34;: \u0026#34;data:image/png;base64,\u0026lt;data\u0026gt;\u0026#34; } このJSONを使って、サーバの各情報が取得できます。\nまた、このパケットを送信するライブラリを探してみたところ、 C#・ Java・ Python3・ PHP 用に作られたコードが見つかりました。 今回は、PHPライブラリを使用しました。\n実装した機能 あまり技術的な話をすると長くなっちゃいそうなので、次に行きます。\n他に実装した機能も紹介します。\n ナビゲーションバー（情クラ！）  再起動（情クラ！） \n   ページ 機能     ピクチャ プレイヤーが自由に画像を投稿することができます   オンラインユーザ ホワイトリストに登録されたプレイヤーが表示され、サーバーに入っているかどうかがわかります   起動・停止 サーバーをしばらく利用しない場合は、GCP課金対策のためにサーバーを切ることができます   再起動 Minecraft サーバーを再起動させることができます   バックアップ実行 Minecraft サーバーのバックアップを作成します（毎日5:00に定期実行されます）   バックアップ履歴 バックアップ履歴の一覧を表示します   情クラマップ 情クラワールドの建築物紹介が載っています   情クラ！公式アプリ 公式アプリへのリンクです    みんなログインしよう 今回サーバーのコントロール機能が Web に公開されるので、ログイン機能を実装する必要があります。 全員 Google アカウントを持っていたので、Firebase Authentication を使って Google ログインを実装しました。\nFirebase に関する記事はたくさんあると思うので、今回説明は省略します。\n以下の公式ドキュメントを読むとよくわかりますよ（雑）\n Firebase Authentication（Google） https://firebase.google.com/docs/auth/web/start?hl=ja\n マイクラサーバーのバックエンドはどうなってるの？ Minecraft サーバーでは、Node.js + TypeScript でAPIを構築しています。\nたとえば、以下は Minecraft サーバーを起動するルーティングの一部抜粋です。\n// --- Start Server ------------------------------------------------------------ router.post(\u0026#39;/api/run/start\u0026#39;, (req: express.Request, res: express.Response) =\u0026gt; { const schema = Joi.object({ user: Joi.string().required(), }) const validation = schema.validate(req.body) if (validation.error) { post(\u0026#34;不正なリクエストを拒否しました\u0026#34;, \u0026#34;ユーザ固有IDが設定されていないリクエストが送信されました\u0026#34;, 3) res.status(400).send(\u0026#39;Bad request\u0026#39;) return } statusAsync(req.body.user) .then(() =\u0026gt; { startAsync(req.body.user) .then(() =\u0026gt; { res.send(\u0026#39;Success\u0026#39;) }) .catch((err) =\u0026gt; { if (err == \u0026#39;failed due to run interval\u0026#39;) post(\u0026#34;起動コマンドを拒否しました\u0026#34;, \u0026#34;前回の処理の実行から\u0026#34; + process.env.WAIT_SECONDS_FROM_LAST_PROCESS + \u0026#34;秒経過していないため、コマンドを拒否しました。\u0026#34;, 2) else post(\u0026#34;起動コマンドを拒否しました\u0026#34;, \u0026#34;サーバーが既に起動しているため、起動コマンドを拒否しました。サーバーとの同期ができていない恐れがあります。[Err: startAsync()]\u0026#34;, 2) res.status(400).send(\u0026#39;Bad request\u0026#39;) }) }) .catch(() =\u0026gt; { post(\u0026#34;起動コマンドを拒否しました\u0026#34;, \u0026#34;既に起動しているため、起動コマンドを拒否しました。サーバーとの同期ができていない恐れがあります。[Err: statusAsync()]\u0026#34;, 2) res.status(400).send(\u0026#39;Bad request\u0026#39;) }) }) // ----------------------------------------------------------------------------- まず、Joi という npm パッケージを利用して、送信されたクエリパラメータなどのバリデーションを行います。 そして、post( ) という関数がありますが、これはサーバーのエラーなどを Discord のサーバーに通知するための関数として用意してあります。 server.jar は screen 上で走らせているのですが、screen の二重起動にならないように初めに起動してもよいかのチェックも行っています。\nまた、実行系はシェルにまとめてあります。\n#!/bin/bash  JARFILE=/home/jokura_server/minecraft/server.jar MEM=15000M cd `dirname $0` screen -UAmdS minecraft java -server -Xms${MEM} -Xmx${MEM} -jar ${JARFILE} nogui 上記のファイルは、起動用のシェルです。\n他にも再起動用やバックアップ用などのシェルも用意してあります。（下記は 再起動用）\n#!/bin/bash  WAIT=30 STARTSCRIPT=/home/jokura_server/minecraft/start.sh SCREEN_NAME=\u0026#39;minecraft\u0026#39; screen -p 0 -S ${SCREEN_NAME} -X eval \u0026#39;stuff \u0026#34;say \u0026#39;${WAIT}\u0026#39;秒後にサーバーを再起動します\\015\u0026#34;\u0026#39; screen -p 0 -S ${SCREEN_NAME} -X eval \u0026#39;stuff \u0026#34;say すぐに再接続可能になるので、しばらくお待ち下さい\\015\u0026#34;\u0026#39; sleep $WAIT screen -p 0 -S ${SCREEN_NAME} -X eval \u0026#39;stuff \u0026#34;stop\\015\u0026#34;\u0026#39; while [ -n \u0026#34;$(screen -list | grep -o \u0026#34;${SCREEN_NAME}\u0026#34;)\u0026#34; ] do sleep 1 done $STARTSCRIPT 今現在の 情クラ！ 今は残念ながら、Webサービスを終了しています。 （Minecraft の活動自体はしています！）\n2021年4月から、Minecraft サーバーを別のメンバーが自宅サーバーで建ててくれることになりました。 やはり GCP などの従量課金制のサーバーで運用するには、かなり気を使ってしまうので正直解放されました。\nかといって、情クラ！での活動はまだまだ続けていく予定なので、ぜひこのブログでも活動を共有していけたらなと思います！\n アクティブすぎるメンバーの写真 \n","date":"2021-04-22T09:06:44+09:00","image":"https://coalabo.net/p/jokura-web/cover_hu009098f9a09b5c87310a26959658631a_93318_120x120_fill_q75_box_smart1.jpg","permalink":"https://coalabo.net/p/jokura-web/","title":"Minecraftサーバーのリモート制御サイトを制作したお話（情クラ！）"}]